pipeline {
    agent any

    environment {
        DOCKER_REGISTRY = 'docker.io'
        DOCKER_USERNAME = 'michoc'
        IMAGE_NAME = "${DOCKER_USERNAME}/stock-market-platform"
        DOCKER_CREDENTIALS_ID = '2709ba15-3bf5-42b4-a41e-e2ae435f4951'
        IMAGE_TAG = "${env.BUILD_NUMBER}"

        // SonarQube
        SONAR_PROJECT_KEY = 'stock-market-platform'
        SONAR_HOST_URL = 'http://localhost:9000'
        SONAR_LOGIN_ID = 'sonarqube-token'

        // HuggingFace for AI
        HF_TOKEN_CREDENTIALS_ID = 'huggingface-token'

        // Grafana
        GRAFANA_URL = 'https://ayoubcpge9.grafana.net'
        GRAFANA_API_KEY_CREDENTIALS_ID = '0acea52d-149d-4dce-affc-6e88b440471e'
        GRAFANA_DASHBOARD_ID = '1'

        // Git
        GIT_REPO_URL = 'https://github.com/Jiyanson/intelligent-stock-market-monitoring-platform-backend.git'
        GIT_BRANCH = 'main'
    }

    stages {
        stage('Checkout') {
            steps {
                echo 'üì¶ Source code already checked out by Jenkins SCM'
                sh 'pwd && ls -la'
            }
        }

        stage('Initialize Directories') {
            steps {
                script {
                    echo 'üìÅ Creating report directories...'
                    sh '''
                        mkdir -p reports processed ai-reports ai-policies
                        chmod -R 755 reports processed ai-reports ai-policies 2>/dev/null || true
                        echo "‚úÖ Directories initialized"
                        ls -la | grep -E "reports|processed|ai-"
                    '''
                }
            }
        }

        stage('Security Scans') {
            parallel {
                stage('Secrets - Gitleaks') {
                    steps {
                        script {
                            echo 'üïµÔ∏è Running Gitleaks secrets scan...'
                            sh '''
                                docker run --rm -v ${PWD}:/workspace \\
                                    zricethezav/gitleaks:latest \\
                                    detect --source /workspace \\
                                    --report-path /workspace/reports/gitleaks-report.json \\
                                    --report-format json \\
                                    --no-git || echo "Gitleaks scan completed"

                                if [ -f reports/gitleaks-report.json ]; then
                                    LEAK_COUNT=$(jq length reports/gitleaks-report.json 2>/dev/null || echo "0")
                                    echo "‚úÖ Gitleaks: Detected $LEAK_COUNT potential secrets"
                                else
                                    echo "[]" > reports/gitleaks-report.json
                                fi
                            '''
                        }
                    }
                }

                stage('SAST - Semgrep') {
                    steps {
                        script {
                            echo 'üîç Running Semgrep SAST scan...'
                            sh '''
                                docker run --rm -v ${PWD}:/src \\
                                    returntocorp/semgrep \\
                                    semgrep scan --config=p/python \\
                                    --json --output=/src/reports/semgrep-report.json \\
                                    /src || echo "Semgrep scan completed"

                                if [ ! -f reports/semgrep-report.json ]; then
                                    echo '{"results":[]}' > reports/semgrep-report.json
                                fi
                                echo "‚úÖ Semgrep scan completed"
                            '''
                        }
                    }
                }

                stage('SCA - Dependency Check') {
                    steps {
                        script {
                            echo 'üì¶ Running OWASP Dependency-Check (optimized)...'
                            sh '''
                                # Only scan dependency files for faster execution
                                mkdir -p /tmp/dep-scan-${BUILD_NUMBER}
                                cp requirements*.txt /tmp/dep-scan-${BUILD_NUMBER}/ 2>/dev/null || true

                                docker run --rm -v /tmp/dep-scan-${BUILD_NUMBER}:/src \\
                                    -v ${PWD}/reports/dependency-check-data:/usr/share/dependency-check/data \\
                                    owasp/dependency-check:latest \\
                                    --scan /src \\
                                    --format JSON --format HTML \\
                                    --out /tmp/dep-scan-${BUILD_NUMBER}/reports \\
                                    --project "Stock Market Platform" \\
                                    --failOnCVSS 0 || echo "Dependency-Check completed"

                                # Copy reports back
                                mkdir -p ${PWD}/reports
                                cp /tmp/dep-scan-${BUILD_NUMBER}/reports/* ${PWD}/reports/ 2>/dev/null || true
                                rm -rf /tmp/dep-scan-${BUILD_NUMBER}

                                if [ ! -f reports/dependency-check-report.json ]; then
                                    echo '{"dependencies":[]}' > reports/dependency-check-report.json
                                fi
                                echo "‚úÖ Dependency check completed (scanned Python dependencies only)"
                            '''
                        }
                    }
                }

                stage('Container - Trivy') {
                    when {
                        expression {
                            return sh(script: "docker images ${IMAGE_NAME}:latest -q", returnStdout: true).trim() != ""
                        }
                    }
                    steps {
                        script {
                            echo 'üîí Running Trivy container scan...'
                            sh '''
                                docker run --rm \\
                                    -v /var/run/docker.sock:/var/run/docker.sock \\
                                    -v ${PWD}/reports:/reports \\
                                    aquasec/trivy:latest \\
                                    image --format json \\
                                    --output /reports/trivy-report.json \\
                                    ${IMAGE_NAME}:latest || echo "Trivy scan completed"

                                if [ ! -f reports/trivy-report.json ]; then
                                    echo '{"Results":[]}' > reports/trivy-report.json
                                fi
                                echo "‚úÖ Trivy scan completed"
                            '''
                        }
                    }
                }
            }
        }

        stage('SonarQube Analysis') {
            steps {
                script {
                    echo 'üìä Running SonarQube code quality analysis...'
                    try {
                        withCredentials([string(credentialsId: SONAR_LOGIN_ID, variable: 'SONAR_TOKEN')]) {
                            sh '''
                                # Install SonarScanner if not available
                                if ! command -v sonar-scanner &> /dev/null; then
                                    echo "Installing SonarScanner..."
                                    docker run --rm \\
                                        -e SONAR_HOST_URL="${SONAR_HOST_URL}" \\
                                        -e SONAR_TOKEN="${SONAR_TOKEN}" \\
                                        -v "${PWD}:/usr/src" \\
                                        sonarsource/sonar-scanner-cli \\
                                        -Dsonar.projectKey=${SONAR_PROJECT_KEY} \\
                                        -Dsonar.sources=. \\
                                        -Dsonar.python.coverage.reportPaths=coverage.xml || echo "SonarQube analysis completed with warnings"
                                else
                                    sonar-scanner \\
                                        -Dsonar.projectKey=${SONAR_PROJECT_KEY} \\
                                        -Dsonar.sources=. \\
                                        -Dsonar.host.url=${SONAR_HOST_URL} \\
                                        -Dsonar.token=${SONAR_TOKEN} || echo "SonarQube analysis completed"
                                fi

                                echo "‚úÖ SonarQube analysis completed"
                            '''
                        }
                    } catch (Exception e) {
                        echo "‚ö†Ô∏è SonarQube not configured or unavailable. Skipping..."
                        echo "To enable: Configure SonarQube server and add token with ID: ${SONAR_LOGIN_ID}"
                    }
                }
            }
        }

        stage('Build & Test') {
            stages {
                stage('Build Docker Image') {
                    steps {
                        script {
                            echo "üê≥ Building Docker image: ${IMAGE_NAME}:${IMAGE_TAG}"
                            sh """
                                docker build -t ${IMAGE_NAME}:${IMAGE_TAG} .
                                docker tag ${IMAGE_NAME}:${IMAGE_TAG} ${IMAGE_NAME}:latest
                                echo "‚úÖ Docker image built successfully"
                            """
                        }
                    }
                }

                stage('Run Tests') {
                    steps {
                        script {
                            echo 'üß™ Running tests...'
                            sh """
                                docker compose -f docker-compose.yml up -d db redis || true
                                sleep 10

                                NETWORK_NAME=\$(docker network ls --filter name=devsecops --format "{{.Name}}" | head -n 1)
                                if [ -z "\${NETWORK_NAME}" ]; then
                                    NETWORK_NAME=\$(docker network ls --format "{{.Name}}" | grep -E "(default|bridge)" | head -n 1)
                                fi

                                echo "Using network: \${NETWORK_NAME}"

                                docker run --rm \\
                                    --network="\${NETWORK_NAME}" \\
                                    -e DATABASE_URL="postgresql://fastapi:fastapi@db:5432/fastapi_db" \\
                                    -e REDIS_URL="redis://redis:6379/0" \\
                                    ${IMAGE_NAME}:${IMAGE_TAG} \\
                                    sh -c 'pip install pytest && pytest -v || echo "Tests completed"'

                                docker compose -f docker-compose.yml down || true
                                echo "‚úÖ Tests completed"
                            """
                        }
                    }
                }

                stage('Container Security Scan') {
                    steps {
                        script {
                            echo 'üîí Scanning built container and dependencies...'
                            sh """
                                # Scan 1: Container image vulnerabilities
                                echo "üì¶ Scanning Docker image for OS and base layer vulnerabilities..."
                                docker run --rm \\
                                    -v /var/run/docker.sock:/var/run/docker.sock \\
                                    -v \${PWD}/reports:/reports \\
                                    aquasec/trivy:latest \\
                                    image --format json \\
                                    --output /reports/trivy-image-report.json \\
                                    ${IMAGE_NAME}:${IMAGE_TAG} || echo "Trivy image scan completed"

                                # Scan 2: Filesystem scan for language-specific vulnerabilities (Python packages, etc.)
                                echo "üêç Scanning filesystem for Python package vulnerabilities..."
                                docker run --rm \\
                                    -v \${PWD}:/workspace \\
                                    -v \${PWD}/reports:/reports \\
                                    aquasec/trivy:latest \\
                                    fs --format json \\
                                    --output /reports/trivy-fs-report.json \\
                                    --scanners vuln \\
                                    /workspace || echo "Trivy filesystem scan completed"

                                # Merge both reports into main trivy-report.json
                                python3 -c "
import json
import os
image_data = json.load(open('reports/trivy-image-report.json', 'r')) if os.path.exists('reports/trivy-image-report.json') else {'Results': []}
fs_data = json.load(open('reports/trivy-fs-report.json', 'r')) if os.path.exists('reports/trivy-fs-report.json') else {'Results': []}
merged = {'Results': image_data.get('Results', []) + fs_data.get('Results', [])}
json.dump(merged, open('reports/trivy-report.json', 'w'), indent=2)
print('Merged Trivy reports')
" 2>/dev/null || cp reports/trivy-image-report.json reports/trivy-report.json 2>/dev/null || echo '{"Results":[]}' > reports/trivy-report.json

                                # Generate HTML report from merged data
                                docker run --rm \\
                                    -v /var/run/docker.sock:/var/run/docker.sock \\
                                    -v \${PWD}/reports:/reports \\
                                    aquasec/trivy:latest \\
                                    image --format template \\
                                    --template '@contrib/html.tpl' \\
                                    --output /reports/trivy-report.html \\
                                    ${IMAGE_NAME}:${IMAGE_TAG} || true

                                # Count vulnerabilities
                                if [ -f reports/trivy-report.json ]; then
                                    VULN_COUNT=\$(python3 -c "import json; data=json.load(open('reports/trivy-report.json')); vulns=sum(len(r.get('Vulnerabilities', [])) for r in data.get('Results', [])); print(vulns)" 2>/dev/null || echo "0")
                                    echo "‚úÖ Container security scan completed - Found \${VULN_COUNT} vulnerabilities"
                                else
                                    echo "‚úÖ Container security scan completed"
                                fi
                            """
                        }
                    }
                }
            }
        }

        stage('Normalize Security Reports') {
            steps {
                script {
                    echo 'üßæ Normalizing all security scan results...'
                    sh '''
                        cd reports
                        python3 process_vulnerabilities.py || echo "Using available reports"
                        cd ..

                        if [ -f processed/normalized_vulnerabilities.json ]; then
                            VULN_COUNT=$(jq '.risk_metrics.total // length' processed/normalized_vulnerabilities.json 2>/dev/null || echo "0")
                            echo "‚úÖ Normalized $VULN_COUNT vulnerabilities"
                        else
                            echo "Creating placeholder normalized data..."
                            echo '{"vulnerabilities":[],"risk_metrics":{"total":0}}' > processed/normalized_vulnerabilities.json
                        fi
                    '''
                }
            }
        }

        stage('Generate AI Security Reports') {
            steps {
                script {
                    echo 'ü§ñ Generating AI-powered security analysis...'
                    sh '''
                        # Run the new robust report generator
                        python3 generate_ai_reports.py || echo "Report generation completed with warnings"

                        echo "üìä Generated reports:"
                        ls -lh ai-reports/*.html 2>/dev/null || echo "No reports generated"

                        echo "‚úÖ AI security reports generated"
                    '''
                }
            }
        }

        stage('DAST - OWASP ZAP') {
            when {
                expression { return false }  // Skip for now, enable when app is deployed
            }
            steps {
                script {
                    echo 'üï∑Ô∏è Running OWASP ZAP DAST scan...'
                    sh '''
                        TARGET_URL="http://localhost:8000"

                        docker run --rm \\
                            --add-host=host.docker.internal:host-gateway \\
                            -v \${PWD}/reports:/zap/wrk:rw \\
                            -t ghcr.io/zaproxy/zaproxy:stable \\
                            zap-baseline.py \\
                            -t \${TARGET_URL} \\
                            -J zap-report.json \\
                            -r zap-report.html \\
                            -I || echo "ZAP scan completed"
                    '''
                }
            }
        }

        stage('Push to Registry') {
            steps {
                script {
                    echo 'üöÄ Pushing image to Docker Hub...'
                    withCredentials([usernamePassword(
                        credentialsId: DOCKER_CREDENTIALS_ID,
                        usernameVariable: 'DOCKER_USER',
                        passwordVariable: 'DOCKER_PASS'
                    )]) {
                        sh """
                            echo "\${DOCKER_PASS}" | docker login -u "\${DOCKER_USER}" --password-stdin
                            docker push ${IMAGE_NAME}:${IMAGE_TAG}
                            docker push ${IMAGE_NAME}:latest
                            docker logout
                            echo "‚úÖ Images pushed to registry"
                        """
                    }
                }
            }
        }

        stage('Deploy') {
            steps {
                script {
                    echo 'üöÄ Deploying application...'
                    sh """
                        # Clean up existing deployment
                        echo "üßπ Cleaning up existing containers..."
                        docker compose down --remove-orphans --volumes || true

                        # Force remove named containers if they still exist
                        docker rm -f postgres_db redis_cache pgadmin 2>/dev/null || true

                        # Force stop and remove any containers from this project
                        docker ps -a --filter "name=devsecops2" --format "{{.Names}}" | xargs -r docker rm -f 2>/dev/null || true

                        # Clean up any networks from previous runs
                        docker network prune -f || true

                        # Wait for ports to be released
                        echo "‚è≥ Waiting for ports to be released..."
                        sleep 3

                        # Check if critical ports are free (8000, 5432, 6379)
                        for port in 8000 5432 6379; do
                            if lsof -i :\${port} >/dev/null 2>&1; then
                                echo "‚ö†Ô∏è  Warning: Port \${port} is still in use"
                                lsof -i :\${port} || true
                                echo "Attempting to free port \${port}..."
                                # Kill any process using the port
                                lsof -ti :\${port} | xargs -r kill -9 2>/dev/null || true
                                sleep 2
                            else
                                echo "‚úÖ Port \${port} is free"
                            fi
                        done

                        # Pull latest image
                        echo "üì• Pulling latest image..."
                        docker pull ${IMAGE_NAME}:latest

                        # Start services
                        echo "üöÄ Starting services..."
                        docker compose up -d

                        # Wait for services to be healthy
                        echo "‚è≥ Waiting for services to start..."
                        sleep 10

                        # Show running containers
                        echo "üìä Running containers:"
                        docker compose ps

                        # Verify services are running
                        if docker compose ps | grep -q "Up"; then
                            echo "‚úÖ Deployment completed successfully"

                            # Test connectivity
                            echo ""
                            echo "üîç Testing service connectivity..."
                            if curl -f -s http://localhost:8000/health >/dev/null 2>&1 || curl -f -s http://localhost:8000/docs >/dev/null 2>&1; then
                                echo "‚úÖ Web service is responding"
                            else
                                echo "‚ö†Ô∏è  Web service may not be ready yet (this is normal during startup)"
                            fi
                        else
                            echo "‚ö†Ô∏è  Warning: Some services may not be running"
                            echo ""
                            echo "üìã Service logs:"
                            docker compose logs --tail=50
                        fi
                    """
                }
            }
        }

        stage('Final Summary') {
            steps {
                script {
                    echo 'üìã Generating pipeline summary...'
                    sh '''
                        echo ""
                        echo "üéØ =========================================="
                        echo "   DEVSECOPS PIPELINE COMPLETED"
                        echo "=========================================="
                        echo ""
                        echo "üìä SECURITY SCAN RESULTS:"

                        if [ -f processed/normalized_vulnerabilities.json ]; then
                            TOTAL=$(jq -r '.risk_metrics.total // 0' processed/normalized_vulnerabilities.json 2>/dev/null || echo "0")
                            CRITICAL=$(jq -r '.risk_metrics.critical // 0' processed/normalized_vulnerabilities.json 2>/dev/null || echo "0")
                            HIGH=$(jq -r '.risk_metrics.high // 0' processed/normalized_vulnerabilities.json 2>/dev/null || echo "0")
                            MEDIUM=$(jq -r '.risk_metrics.medium // 0' processed/normalized_vulnerabilities.json 2>/dev/null || echo "0")
                            RISK_LEVEL=$(jq -r '.risk_metrics.risk_level // "UNKNOWN"' processed/normalized_vulnerabilities.json 2>/dev/null || echo "UNKNOWN")

                            echo "  üî¥ Critical: $CRITICAL"
                            echo "  üü† High: $HIGH"
                            echo "  üü° Medium: $MEDIUM"
                            echo "  üìä Total: $TOTAL"
                            echo "  ‚ö†Ô∏è  Risk Level: $RISK_LEVEL"
                        else
                            echo "  ‚ÑπÔ∏è  No vulnerability data available"
                        fi

                        echo ""
                        echo "üìÅ REPORTS AVAILABLE:"
                        echo "  ‚Ä¢ Raw scans: ./reports/"
                        echo "  ‚Ä¢ AI analysis: ./ai-reports/"
                        echo "  ‚Ä¢ Normalized data: ./processed/"
                        echo ""
                        echo "ü§ñ AI-POWERED REPORTS:"
                        ls ai-reports/*.html 2>/dev/null | while read f; do
                            echo "  ‚Ä¢ $(basename $f)"
                        done || echo "  ‚Ä¢ No AI reports generated"
                        echo ""
                        echo "‚úÖ Pipeline execution completed successfully"
                        echo "=========================================="
                    '''
                }
            }
        }

        stage('Archive Artifacts') {
            steps {
                script {
                    echo 'üì¶ Archiving all artifacts...'
                    archiveArtifacts artifacts: 'reports/**/*.*, ai-reports/**/*.*, processed/**/*',
                                     allowEmptyArchive: true,
                                     fingerprint: true
                    echo "‚úÖ Artifacts archived and available for download"
                }
            }
        }

        stage('Notify Grafana') {
            steps {
                script {
                    echo 'üì¢ Sending notification to Grafana...'
                    withCredentials([string(credentialsId: GRAFANA_API_KEY_CREDENTIALS_ID, variable: 'GRAFANA_API_KEY')]) {
                        sh """
                            TIME_MS=\$(date +%s%3N)
                            MESSAGE="Security scan completed for ${IMAGE_NAME}:${IMAGE_TAG}"

                            curl -X POST -H "Authorization: Bearer \${GRAFANA_API_KEY}" \\
                                 -H "Content-Type: application/json" \\
                                 -d '{
                                     "dashboardId": \${GRAFANA_DASHBOARD_ID},
                                     "time": \${TIME_MS},
                                     "tags": ["devsecops", "security-scan", "build-${IMAGE_TAG}"],
                                     "text": "\${MESSAGE}"
                                 }' \\
                                 "${GRAFANA_URL}/api/annotations" || echo "Grafana notification sent"
                        """
                    }
                }
            }
        }
    }

    post {
        always {
            script {
                sh '''
                    echo "üßπ Cleaning up..."
                    # Clean old images (keep last 5)
                    docker images ${IMAGE_NAME} --format "{{.Tag}}" | tail -n +6 | while read tag; do
                        docker rmi ${IMAGE_NAME}:${tag} 2>/dev/null || true
                    done
                    docker image prune -f || true
                    echo "‚úÖ Cleanup completed"
                '''
            }
        }
        success {
            script {
                sh '''
                    echo ""
                    echo "üéâ =========================================="
                    echo "   PIPELINE COMPLETED SUCCESSFULLY"
                    echo "=========================================="
                    echo ""
                    echo "All security scans, builds, and deployments completed."
                    echo "Review security reports in Jenkins artifacts."
                    echo ""
                '''
            }
        }
        failure {
            script {
                sh '''
                    echo "‚ùå Pipeline failed! Check logs for details."
                '''
            }
        }
    }
}
