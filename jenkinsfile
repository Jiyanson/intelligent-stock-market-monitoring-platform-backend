pipeline {
    agent any

    environment {
        // Docker Hub credentials
        DOCKER_REGISTRY = 'docker.io'
        DOCKER_USERNAME = 'michoc'
        IMAGE_NAME = "${DOCKER_USERNAME}/stock-market-platform"
        DOCKER_CREDENTIALS_ID = '2709ba15-3bf5-42b4-a41e-e2ae435f4951'

        // Git repository
        GIT_REPO_URL = 'https://github.com/Jiyanson/intelligent-stock-market-monitoring-platform-backend.git'
        GIT_CREDENTIALS_ID = 'github-credentials'
        GIT_BRANCH = 'main'

        // Image tag
        IMAGE_TAG = "${env.BUILD_NUMBER}"

        // Deployment server (optional, for remote deployment)
        DEPLOY_SERVER = 'user@your-server.com'
        DEPLOY_SERVER_CREDENTIALS_ID = 'deploy-server-ssh'

        // Grafana variables
        GRAFANA_URL = 'https://ayoubcpge9.grafana.net'
        GRAFANA_API_KEY_CREDENTIALS_ID = '0acea52d-149d-4dce-affc-6e88b440471e'
        GRAFANA_DASHBOARD_ID = '1'

        // HuggingFace API for AI Security Policy Generation
        HF_TOKEN_CREDENTIALS_ID = 'huggingface-token' // Jenkins Secret Text credential

        // Report directories
        REPORTS_DIR = 'reports'
        PROCESSED_DIR = 'processed'
        AI_POLICIES_DIR = 'ai-policies'
    }
    
    stages {
        stage('Checkout') {
            steps {
                echo 'üì¶ Checking out source code...'
                script {
                    git branch: "${GIT_BRANCH}", url: "${GIT_REPO_URL}"
                }
            }
        }

        stage('Prepare Directories') {
            steps {
                echo 'üìÅ Creating report directories...'
                sh """
                    mkdir -p ${REPORTS_DIR}
                    mkdir -p ${PROCESSED_DIR}
                    mkdir -p ${AI_POLICIES_DIR}
                """
            }
        }

        stage('Gitleaks - Secrets Scanning') {
            steps {
                script {
                    echo 'üîç Running Gitleaks for secrets detection...'
                    sh """
                        docker run --rm -v \${PWD}:/workspace \\
                            zricethezav/gitleaks:latest \\
                            detect --source /workspace \\
                            --report-path /workspace/${REPORTS_DIR}/gitleaks-report.json \\
                            --report-format json \\
                            --no-git || echo "Gitleaks scan completed (findings may exist)"
                    """
                }
            }
        }

        stage('Semgrep - SAST') {
            steps {
                script {
                    echo 'üîç Running Semgrep SAST scan...'
                    sh """
                        docker run --rm -v \${PWD}:/src \\
                            returntocorp/semgrep \\
                            semgrep scan --config=p/python \\
                            --json --output=/src/${REPORTS_DIR}/semgrep-report.json \\
                            /src || echo "Semgrep scan completed (findings may exist)"
                    """
                }
            }
        }

        stage('Dependency-Check - SCA') {
            steps {
                script {
                    echo 'üîç Running OWASP Dependency-Check for SCA...'
                    sh """
                        # Use unique data directory per build to avoid locking issues
                        docker run --rm -v \${PWD}:/src \\
                            -v \${PWD}/${REPORTS_DIR}/dependency-check-data:/usr/share/dependency-check/data \\
                            owasp/dependency-check:latest \\
                            --scan /src \\
                            --format JSON \\
                            --format HTML \\
                            --out /src/${REPORTS_DIR} \\
                            --project "Stock Market Platform" \\
                            --nvdApiKey \${NVD_API_KEY:-NONE} || echo "Dependency-Check scan completed (findings may exist)"

                        # Rename output files to match expected names if they exist
                        if [ -f "${REPORTS_DIR}/dependency-check-report.json" ]; then
                            echo "‚úÖ Dependency-Check JSON report generated"
                        else
                            echo "{}" > ${REPORTS_DIR}/dependency-check-report.json
                        fi
                    """
                }
            }
        }

        stage('Build Docker Image') {
            steps {
                script {
                    echo "üê≥ Building Docker image: ${IMAGE_NAME}:${IMAGE_TAG}"
                    sh """
                        docker build -t ${IMAGE_NAME}:${IMAGE_TAG} .
                        docker tag ${IMAGE_NAME}:${IMAGE_TAG} ${IMAGE_NAME}:latest
                    """
                }
            }
        }

        stage('Run Tests') {
            steps {
                script {
                    echo 'üß™ Running tests...'
                    sh """
                        docker compose -f docker-compose.yml up -d db redis || true
                        sleep 10

                        # Get the actual network name created by docker-compose
                        NETWORK_NAME=\$(docker network ls --filter name=devsecops --format "{{.Name}}" | head -n 1)

                        # If no network found, try the default pattern
                        if [ -z "\${NETWORK_NAME}" ]; then
                            NETWORK_NAME=\$(docker network ls --format "{{.Name}}" | grep -E "(default|bridge)" | head -n 1)
                        fi

                        echo "Using network: \${NETWORK_NAME}"

                        docker run --rm \\
                            --network="\${NETWORK_NAME}" \\
                            -e DATABASE_URL="postgresql://fastapi:fastapi@db:5432/fastapi_db" \\
                            -e REDIS_URL="redis://redis:6379/0" \\
                            ${IMAGE_NAME}:${IMAGE_TAG} \\
                            sh -c 'pip install pytest && pytest -v || echo "No tests found"'
                        docker compose -f docker-compose.yml down || true
                    """
                }
            }
        }
        
        stage('Code Quality Checks') {
            steps {
                script {
                    echo 'üîç Running code quality checks...'
                    sh """
                        docker run --rm ${IMAGE_NAME}:${IMAGE_TAG} \\
                            sh -c 'black --check app/ || echo "Black formatting check completed with warnings"'
                    """
                    sh """
                        docker run --rm ${IMAGE_NAME}:${IMAGE_TAG} \\
                            sh -c 'isort --check-only app/ || echo "isort check completed with warnings"'
                    """
                }
            }
        }
        
        stage('Trivy - Container Image Scan') {
            steps {
                script {
                    echo 'üîí Running Trivy container image scan...'
                    sh """
                        # Generate JSON report
                        docker run --rm \\
                            -v /var/run/docker.sock:/var/run/docker.sock \\
                            -v \${PWD}/${REPORTS_DIR}:/reports \\
                            aquasec/trivy:latest \\
                            image --format json \\
                            --output /reports/trivy-report.json \\
                            ${IMAGE_NAME}:${IMAGE_TAG} || echo "Trivy scan completed (vulnerabilities may exist)"

                        # Generate HTML report
                        docker run --rm \\
                            -v /var/run/docker.sock:/var/run/docker.sock \\
                            -v \${PWD}/${REPORTS_DIR}:/reports \\
                            aquasec/trivy:latest \\
                            image --format template \\
                            --template '@contrib/html.tpl' \\
                            --output /reports/trivy-report.html \\
                            ${IMAGE_NAME}:${IMAGE_TAG} || echo "Trivy HTML report generation completed"
                    """
                }
            }
        }
        
        stage('Push to Docker Hub') {
            steps {
                script {
                    echo 'üöÄ Pushing image to Docker Hub...'
                    withCredentials([usernamePassword(
                        credentialsId: DOCKER_CREDENTIALS_ID,
                        usernameVariable: 'DOCKER_USER',
                        passwordVariable: 'DOCKER_PASS'
                    )]) {
                        sh """
                            echo "${DOCKER_PASS}" | docker login -u "${DOCKER_USER}" --password-stdin
                            docker push ${IMAGE_NAME}:${IMAGE_TAG}
                            docker push ${IMAGE_NAME}:latest
                            docker logout
                        """
                    }
                }
            }
        }
        
        stage('Deploy with Docker Compose') {
            steps {
                script {
                    echo 'üöÄ Deploying to Docker Desktop...'
                    sh """
                        docker compose down || true
                        docker pull ${IMAGE_NAME}:latest
                        docker compose up -d
                        echo "Waiting for services to start..."
                        sleep 20
                        docker compose ps
                        docker compose logs --tail=20
                        echo "Testing API health..."
                        for i in {1..5}; do
                            if curl -f http://localhost:8000/api/v1/finance/health; then
                                echo "‚úÖ API is healthy!"
                                break
                            else
                                echo "Attempt \$i: API not ready yet, waiting..."
                                sleep 5
                            fi
                        done
                    """
                }
            }
        }

        stage('OWASP ZAP - DAST') {
            steps {
                script {
                    echo 'üîç Running OWASP ZAP DAST scan...'
                    sh """
                        # Try FastAPI on port 8000, fallback to nginx on 8001
                        TARGET_URL="http://host.docker.internal:8000"

                        # Check if FastAPI is accessible
                        if ! curl -f \${TARGET_URL}/api/v1/finance/health 2>/dev/null; then
                            echo "FastAPI not accessible on 8000, trying nginx on 8001..."
                            TARGET_URL="http://host.docker.internal:8001"
                        fi

                        echo "Running ZAP baseline scan against \${TARGET_URL}..."

                        docker run --rm \\
                            --add-host=host.docker.internal:host-gateway \\
                            -v \${PWD}/${REPORTS_DIR}:/zap/wrk:rw \\
                            -t ghcr.io/zaproxy/zaproxy:stable \\
                            zap-baseline.py \\
                            -t \${TARGET_URL} \\
                            -J zap-report.json \\
                            -r zap-report.html \\
                            -I || echo "ZAP scan completed (findings may exist)"
                    """
                }
            }
        }

        stage('Normalize Reports') {
            steps {
                script {
                    echo 'üìä Normalizing security reports...'
                    sh """
                        # Check if the normalization script exists
                        if [ -f "${REPORTS_DIR}/process_vulnerabilities.py" ]; then
                            docker run --rm \\
                                -v \${PWD}/${REPORTS_DIR}:/reports \\
                                -v \${PWD}/${PROCESSED_DIR}:/processed \\
                                python:3.11-slim \\
                                sh -c "pip install -q jq && python /reports/process_vulnerabilities.py" \\
                                || echo "Report normalization completed with warnings"
                        else
                            echo "‚ö†Ô∏è Normalization script not found at ${REPORTS_DIR}/process_vulnerabilities.py"
                            echo "Creating placeholder normalized report..."
                            echo '{"vulnerabilities": [], "summary": "Normalization script not found"}' > ${PROCESSED_DIR}/normalized_vulnerabilities.json
                        fi
                    """
                }
            }
        }

        stage('AI Security Policy Generation') {
            steps {
                script {
                    echo 'ü§ñ Generating AI-based security policies and HTML reports...'
                    // Check if HF_TOKEN credential exists, otherwise skip
                    try {
                        withCredentials([string(credentialsId: HF_TOKEN_CREDENTIALS_ID, variable: 'HF_TOKEN')]) {
                            sh """
                                # Check if the AI integration scripts exist
                                if [ -f "real_llm_integration.py" ] && [ -f "llm_integration.py" ] && [ -f "html_report_generator.py" ]; then
                                    echo "‚úÖ All AI security scripts found"

                                    # Run AI security analysis and report generation
                                    docker run --rm \\
                                        -e HF_TOKEN=\${HF_TOKEN} \\
                                        -v \${PWD}:/workspace \\
                                        -w /workspace \\
                                        python:3.11-slim \\
                                        sh -c "pip install -q -r requirements-security.txt && python3 real_llm_integration.py" \\
                                        || echo "‚ö†Ô∏è AI policy generation completed with warnings"

                                    echo "‚úÖ AI-powered security analysis complete!"
                                    echo "üìä Generated reports:"
                                    ls -lh ${REPORTS_DIR}/*.html 2>/dev/null || echo "No HTML reports found"
                                    ls -lh ${AI_POLICIES_DIR}/*.json 2>/dev/null || echo "No AI policies found"
                                else
                                    echo "‚ö†Ô∏è AI integration scripts not found"
                                    echo "Required files: real_llm_integration.py, llm_integration.py, html_report_generator.py"
                                    echo "Creating placeholder AI policy..."
                                    mkdir -p ${AI_POLICIES_DIR}
                                    echo '{"policy": "AI integration scripts not found", "recommendations": []}' > ${AI_POLICIES_DIR}/llm_generated_policy.json
                                fi
                            """
                        }
                    } catch (Exception e) {
                        echo "‚ö†Ô∏è HuggingFace token credential not configured. Skipping AI policy generation."
                        echo "To enable, add a Jenkins Secret Text credential with ID: ${HF_TOKEN_CREDENTIALS_ID}"
                        echo "Get your token from: https://huggingface.co/settings/tokens"
                        sh """
                            mkdir -p ${AI_POLICIES_DIR}
                            echo '{"policy": "HF_TOKEN not configured", "recommendations": []}' > ${AI_POLICIES_DIR}/llm_generated_policy.json
                        """
                    }
                }
            }
        }

        stage('Archive Reports') {
            steps {
                echo 'üì¶ Archiving security reports and AI-generated artifacts...'
                archiveArtifacts artifacts: "${REPORTS_DIR}/**/*.json,${REPORTS_DIR}/**/*.html,${PROCESSED_DIR}/**/*.json,${AI_POLICIES_DIR}/**/*.json",
                                 allowEmptyArchive: true,
                                 fingerprint: true
                echo '‚úÖ Archived artifacts:'
                echo '   - Security scan reports (JSON/HTML)'
                echo '   - Normalized vulnerability data'
                echo '   - AI-generated policies and playbooks'
                echo '   - Comprehensive/Executive/Technical HTML reports'
            }
        }

        stage('Grafana Notification') {
            steps {
                script {
                    echo 'üì¢ Sending deployment annotation to Grafana...'
                    withCredentials([string(credentialsId: GRAFANA_API_KEY_CREDENTIALS_ID, variable: 'GRAFANA_API_KEY')]) {
                        sh """
                            TIME_MS=\$(date +%s%3N)
                            MESSAGE="Deployment of ${IMAGE_NAME} complete! Tag: ${IMAGE_TAG} (Build \${BUILD_NUMBER})"
                            
                            curl -X POST -H "Authorization: Bearer \${GRAFANA_API_KEY}" \\
                                 -H "Content-Type: application/json" \\
                                 -d '{
                                     "dashboardId": \${GRAFANA_DASHBOARD_ID},
                                     "time": \${TIME_MS},
                                     "tags": ["deployment", "jenkins", "success", "${IMAGE_TAG}"],
                                     "text": "\${MESSAGE}"
                                 }' \\
                                 "${GRAFANA_URL}/api/annotations" || echo "Failed to send Grafana annotation (is API key valid?)"
                        """
                    }
                }
            }
        }
    }
    
    post {
        success {
            echo '‚úÖ Pipeline completed successfully!'
        }
        failure {
            echo '‚ùå Pipeline failed! Check logs for details.'
        }
        always {
            echo 'üßπ Cleaning up old images...'
            sh """
                # Clean up old images (keep last 5)
                docker images ${IMAGE_NAME} --format "{{.Tag}}" | tail -n +6 | while read tag; do
                    docker rmi ${IMAGE_NAME}:\${tag} || true
                done
                # Prune dangling images
                docker image prune -f || true
            """
        }
    }
}